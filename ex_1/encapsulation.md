# Инкапсуляция и области видимости

Инкапсуляция - один из четырёх основных принципов ООП (наряду с наследованием, полиморфизмом и абстракцией).
Инкапсуляция предполагает сокрытие внутренних деталей реализации класса и ограничение прямого доступа к его атрибутам и методам.

Области видимости (scope) определяют, из каких частей программы доступны переменные и функции.
В Python области видимости следуют правилу LEGB:
- Local - локальная область (внутри функции)
- Enclosing - объемлющая область (внешняя функция для вложенных функций)
- Global - глобальная область (уровень модуля)
- Built-in - встроенная область (встроенные функции Python)

## Проблема
Без инкапсуляции любой код может изменить данные объекта напрямую.
Это приводит к:
- Некорректным состояниям объекта (например, отрицательный возраст)
- Сложности отладки (непонятно, кто изменил данные)
- Зависимости от внутренней реализации (изменение класса ломает весь код)
- Нарушению инвариантов класса (условий, которые всегда должны быть истинны)

## Решение
Скрыть данные и предоставить контролируемый доступ через методы.

В Python существует 3 уровня доступа к данным класса:
- **public** (`attr`) - установлен по умолчанию, данные доступны везде
- **protected** (`_attr`) - данные доступны классу и наследникам (соглашение)
- **private** (`__attr`) - данные доступны только внутри класса

### Name Mangling (искажение имён)
Для private атрибутов Python применяет name mangling: `__attr` → `_ClassName__attr`.
Это не полноценная защита, а защита от случайного переопределения в подклассах.

```python
class MyClass:
    def __init__(self):
        self.__private = "ляляля"

obj = MyClass()
# obj.__private  # AttributeError
obj._MyClass__private  # Возвращает "ляляля"
```

## Аналогия
Банкомат (объект) и PIN-код (приватный атрибут). 
Нельзя напрямую достать деньги - только через интерфейс (методы): ввести PIN, выбрать сумму.

## Защита на уровне объекта
Атрибуты экземпляра класса защищены от прямого доступа извне.

Для взаимодействия используются:
- **геттер (getter)** - метод для чтения значения
- **сеттер (setter)** - метод для изменения значения с валидацией

### Декораторы property
Property позволяет обращаться к методам как к атрибутам:
- `@property` - определяет геттер (только чтение)
- `@name.setter` - определяет сеттер (запись с валидацией)
- `@name.deleter` - определяет делитер (удаление)


## Защита на уровне класса
Атрибуты класса, общие для всех экземпляров, также могут быть защищены.

Приватные атрибуты класса (`__attr`) доступны только через:
- **@classmethod** - метод класса, первый аргумент `cls` (сам класс)
- **@staticmethod** - статический метод, не имеет доступа к классу или экземпляру


## Преимущества
- Контроль доступа и валидация данных
- Независимость от внутренней реализации (можно менять внутреннюю структуру)
- Упрощение отладки (все изменения проходят через методы)
- Соблюдение принципа сокрытия информации (information hiding)

## Недостатки
- Дополнительный код (геттеры/сеттеры)
- В Python защита основана на соглашениях - можно обойти
- Может усложнить простые классы

## Источники
- Бизли Д. "Python. Исчерпывающее руководство" - Глава 7.15 ("Инкапсуляция данных и приватные атрибуты")
https://clck.ru/3QtNSS
- Рамальо Л. "Python. К вершинам мастерства" - Стр.368-370 ("Закрытые и «защищенные» атрибуты в Python")
https://clck.ru/3QtNRd
- https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces